# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

sSS_exp_Q <- function(Q, prec, renorm = TRUE) {
    .Call(`_expQ2_sSS_exp_Q`, Q, prec, renorm)
}

dSS_exp_Q <- function(Q, prec, renorm = TRUE) {
    .Call(`_expQ2_dSS_exp_Q`, Q, prec, renorm)
}

#' Exponentiate a rate matrix
#'
#' Exponentiates a whole rate matrix by making all elements non-negative, then  scaling and squaring.
#'
#' @param Q Rate matrix (sparse or dense).
#' @param prec Required precision - missing mass in the Poisson distribution.
#' @param renorm Force elements of each row to sum to 1? Defaults to TRUE.
#' @return exp(Q) A dense matrix.
#' @export
#'
#' @author Chris Sherlock
#'
#' @examples
#' Qd <- matrix(nrow=2,ncol=2,data=c(-1,1,2,-2),byrow=TRUE); SS_exp_Q(Qd,1e-10)
#'
#' library("Matrix")
#' d<-5; f<-0.3; ones<-rep(1,d)
#' Qs <- abs(rsparsematrix(d,d,f))
#' diag(Qs) <- 0
#' Qsum <- as.vector(Qs%*%ones)
#' diag(Qs) <- -Qsum
#' SS_exp_Q(Qs,1e-15)
#'
#' \dontrun{
#' M <- matrix(nrow=2,ncol=2,data=c(1,1,2,2),byrow=TRUE); SS_exp_Q(M,1e-10)
#' M <- matrix(nrow=2,ncol=2,data=c(1,-1,-2,2),byrow=TRUE); SS_exp_Q(M,1e-10)
#' SS_exp_Q(Qs,1.5)
#' SS_exp_Q(Qs,-2.0)
#'}
SS_exp_Q <- function(Q, prec, renorm = TRUE) {
    .Call(`_expQ2_SS_exp_Q`, Q, prec, renorm)
}

sSS_v_exp_Q <- function(v, Q, prec, renorm = TRUE) {
    .Call(`_expQ2_sSS_v_exp_Q`, v, Q, prec, renorm)
}

dSS_v_exp_Q <- function(v, Q, prec, renorm = TRUE) {
    .Call(`_expQ2_dSS_v_exp_Q`, v, Q, prec, renorm)
}

#' Product of horizontal vector and exponential of a rate matrix
#'
#' Evaluates v Exp(Q) by making all elements of Q non-negative, then scaling down by a power of two, and finally using a mixture of squaring and vector-matrix products.
#'
#' @author Chris Sherlock
#'
#' @param v Non-negative horizontal vector (dense).
#' @param Q Rate matrix (sparse or dense).
#' @param prec Required precision - missing mass in the Poisson distribution.
#' @param renorm Force elements of each row to sum to 1? Defaults to TRUE.
#' @param checks Perform sanity checks on the arguments? Defaults to TRUE.
#' @return v exp(Q) A dense horizontal vector.
#' @export
#'
#' @examples
#' v<-runif(2); v<-v/sum(v)
#' Qd <- matrix(nrow=2,ncol=2,data=c(-1,1,2,-2),byrow=TRUE); SS_v_exp_Q(t(v),Qd,1e-10)
#'
#' library("Matrix")
#' d<-5; f<-0.3; ones<-rep(1,d); v<-runif(d)
#' Qs <- abs(rsparsematrix(d,d,f))
#' diag(Qs) <- 0
#' Qsum <- as.vector(Qs%*%ones)
#' diag(Qs) <- -Qsum
#' SS_v_exp_Q(t(v),Qs,1e-15)
#'
#' \dontrun{
#' v <- runif(2); 
#' M <- matrix(nrow=2,ncol=2,data=c(1,1,2,2),byrow=TRUE); SS_v_exp_Q(t(v),M,1e-10)
#' M <- matrix(nrow=2,ncol=2,data=c(1,-1,-2,2),byrow=TRUE); SS_v_exp_Q(t(v),M,1e-10)
#' d<-5; f<-0.3; ones<-rep(1,d); v<-runif(d)
#' Qs <- abs(rsparsematrix(d,d,f))
#' diag(Qs) <- 0; Qsum <- as.vector(Qs%*%ones); diag(Qs) <- -Qsum
#' SS_v_exp_Q(v,Qs,1e-15)
#' SS_v_exp_Q(t(v),Qs,1.5)
#' SS_v_exp_Q(t(v),Qs,-2.0)
#' v=-runif(d)
#' SS_v_exp_Q(t(v),Qs,1e-15)
#'}
SS_v_exp_Q <- function(v, Q, prec, renorm = TRUE, checks = TRUE) {
    .Call(`_expQ2_SS_v_exp_Q`, v, Q, prec, renorm, checks)
}

sUnif_v_exp_Q <- function(v, Q, prec, renorm = TRUE, t2 = TRUE) {
    .Call(`_expQ2_sUnif_v_exp_Q`, v, Q, prec, renorm, t2)
}

dUnif_v_exp_Q <- function(v, Q, prec, renorm = TRUE, t2 = TRUE) {
    .Call(`_expQ2_dUnif_v_exp_Q`, v, Q, prec, renorm, t2)
}

#' Product of horizontal vector and exponential of rate matrix
#'
#' Evaluates v exp(Q) by making all elements of Q non-negative, then using the uniformisation method.
#'
#' @author Chris Sherlock
#'
#' @param v Non-negative horizontal vector (dense).
#' @param Q Rate matrix (sparse or dense).
#' @param prec Required precision - missing mass in the Poisson distribution.
#' @param renorm Force elements of each row to sum to 1? Defaults to TRUE.
#' @param t2 Perform two-tailed truncation? Defaults to TRUE.
#' @param checks Perform sanity checks on the arguments? Defaults to TRUE.
#' @return v exp(Q) Dense horizontal vector.
#' @export
#'
#' @examples
#' v <- runif(2); v <- v/sum(v)
#' Qd <- matrix(nrow=2,ncol=2,data=c(-1,1,2,-2),byrow=TRUE); Unif_v_exp_Q(t(v),Qd,1e-10)
#'
#' library("Matrix")
#' d <- 5; f <- 0.3; ones <- rep(1,d); v <- runif(d)
#' Qs <- abs(rsparsematrix(d,d,f))
#' diag(Qs) <- 0
#' Qsum <- as.vector(Qs%*%ones)
#' diag(Qs) <- -Qsum
#' Unif_v_exp_Q(t(v),Qs,1e-15)
#'
#' \dontrun{
#' v <- runif(2); 
#' M <- matrix(nrow=2,ncol=2,data=c(1,1,2,2),byrow=TRUE); Unif_v_exp_Q(t(v),M,1e-10)
#' M <- matrix(nrow=2,ncol=2,data=c(1,-1,-2,2),byrow=TRUE); Unif_v_exp_Q(t(v),M,1e-10)
#' d <- 5; f <- 0.3; ones <- rep(1,d); v <- runif(d)
#' Qs <- abs(rsparsematrix(d,d,f))
#' diag(Qs) <- 0; Qsum <- as.vector(Qs%*%ones); diag(Qs) <- -Qsum
#' Unif_v_exp_Q(v,Qs,1e-15)
#' Unif_v_exp_Q(t(v),Qs,1.5)
#' Unif_v_exp_Q(t(v),Qs,-2.0)
#' v <- -runif(d)
#' Unif_v_exp_Q(t(v),Qs,1e-15)
#'}
Unif_v_exp_Q <- function(v, Q, prec, renorm = TRUE, t2 = TRUE, checks = TRUE) {
    .Call(`_expQ2_Unif_v_exp_Q`, v, Q, prec, renorm, t2, checks)
}

should_use_SS_sparse <- function(d, rho, f) {
    .Call(`_expQ2_should_use_SS_sparse`, d, rho, f)
}

should_use_SS_dense <- function(d, rho) {
    .Call(`_expQ2_should_use_SS_dense`, d, rho)
}

sv_exp_Q <- function(v, Q, prec, renorm = TRUE, t2 = TRUE) {
    .Call(`_expQ2_sv_exp_Q`, v, Q, prec, renorm, t2)
}

dv_exp_Q <- function(v, Q, prec, renorm = TRUE, t2 = TRUE) {
    .Call(`_expQ2_dv_exp_Q`, v, Q, prec, renorm, t2)
}

#' Product of horizontal vector and exponential of rate matrix
#'
#' Evaluates v exp(Q); automatically chooses between scaling and squaring or uniformisation.
#'
#' @author Chris Sherlock
#'
#' @param v Non-negative horizontal vector (dense).
#' @param Q Rate matrix (sparse or dense).
#' @param prec Required precision - missing mass in the Poisson distribution.
#' @param renorm Force elements of each row to sum to 1? Defaults to TRUE.
#' @param t2 Perform two-tailed truncation? Defaults to TRUE.
#' @param checks Perform sanity checks on the arguments? Defaults to TRUE.
#' @return v exp(Q) Dense horizontal vector.
#' @export
#'
#' @examples
#' v <- runif(2); v <- v/sum(v)
#' Qd <- matrix(nrow=2,ncol=2,data=c(-1,1,2,-2),byrow=TRUE); v_exp_Q(t(v),Qd,1e-10)
#'
#' library("Matrix")
#' d <- 5; f=0.3; ones <- rep(1,d); v <- runif(d)
#' Qs <- abs(rsparsematrix(d,d,f))
#' diag(Qs) <- 0
#' Qsum <- as.vector(Qs%*%ones)
#' diag(Qs) <- -Qsum
#' v_exp_Q(t(v),Qs,1e-15)
#'
#' \dontrun{
#' v <- runif(2); 
#' M <- matrix(nrow=2,ncol=2,data=c(1,1,2,2),byrow=TRUE); v_exp_Q(t(v),M,1e-10)
#' M <- matrix(nrow=2,ncol=2,data=c(1,-1,-2,2),byrow=TRUE); v_exp_Q(t(v),M,1e-10)
#' d <- 5; f=0.3; ones <- rep(1,d); v <- runif(d)
#' Qs <- abs(rsparsematrix(d,d,f))
#' diag(Qs) <- 0; Qsum <- as.vector(Qs%*%ones); diag(Qs) <- -Qsum
#' v_exp_Q(v,Qs,1e-15)
#' v_exp_Q(t(v),Qs,1.5)
#' v_exp_Q(t(v),Qs,-2.0)
#' v <- -runif(d)
#' v_exp_Q(t(v),Qs,1e-15)
#'}
v_exp_Q <- function(v, Q, prec, renorm = TRUE, t2 = TRUE, checks = TRUE) {
    .Call(`_expQ2_v_exp_Q`, v, Q, prec, renorm, t2, checks)
}

#' Vector transpose * exponential of a rate matrix, all transposed.
#'
#' Evaluates [v' exp(Q)]'; automatically chooses between scaling and squaring or uniformisation.
#'
#' @author Chris Sherlock
#'
#' @param v Non-negative vertical vector (dense).
#' @param Q Rate matrix (sparse or dense).
#' @param prec Required precision - missing mass in the Poisson distribution.
#' @param renorm Force elements of each row to sum to 1? Defaults to TRUE.
#' @param t2 Perform two-tailed truncation? Defaults to TRUE.
#' @param checks Perform sanity checks on the arguments? Defaults to TRUE.
#' @return [v' exp(Q)]' Dense vertical vector.
#' @export
#'
#' @examples
#' v <- runif(2); v <- v/sum(v)
#' Qd <- matrix(nrow=2,ncol=2,data=c(-1,1,2,-2),byrow=TRUE); vT_exp_Q(v,Qd,1e-10)
#'
#' library("Matrix")
#' d <- 5; f <- 0.3; ones <- rep(1,d); v <- runif(d)
#' Qs <- abs(rsparsematrix(d,d,f))
#' diag(Qs) <- 0; Qsum <- as.vector(Qs%*%ones); diag(Qs) <- -Qsum
#' vT_exp_Q(v,Qs,1e-15)
#'
#' \dontrun{
#' v <- runif(2); 
#' M <- matrix(nrow=2,ncol=2,data=c(1,1,2,2),byrow=TRUE); vT_exp_Q(v,M,1e-10)
#' M <- matrix(nrow=2,ncol=2,data=c(1,-1,-2,2),byrow=TRUE); vT_exp_Q(v,M,1e-10)
#' d <- 5; f <- 0.3; ones <- rep(1,d); v <- runif(d)
#' Qs=abs(rsparsematrix(d,d,f))
#' diag(Qs) <- 0; Qsum <- as.vector(Qs%*%ones); diag(Qs) <- -Qsum
#' vT_exp_Q(t(v),Qs,1e-15)
#' vT_exp_Q(v,Qs,1.5)
#' vT_exp_Q(v,Qs,-2.0)
#' v=-runif(d)
#' vT_exp_Q(v,Qs,1e-15)
#'}
vT_exp_Q <- function(v, Q, prec, renorm = TRUE, t2 = TRUE, checks = TRUE) {
    .Call(`_expQ2_vT_exp_Q`, v, Q, prec, renorm, t2, checks)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('_expQ2_RcppExport_registerCCallable', PACKAGE = 'expQ2')
})
